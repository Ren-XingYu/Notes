
```
[]		里面的内容出现一次		[0-9] [a-zA-Z0-9]
()		捕获分组					a(bc)+,每组是有序号的(看左括号),编号从1开始
			正则内部	\X: 表示把第X组的内容再拿出来用一次
			正则外部	$X: 表示把第X组的内容再拿出来用一次
				我要学学编编编程程程程  -> 我要学编程		正则: replaceAll("(.)\\1+", "$1")
^		取反					[^abc]
&&		交集,不能写单个&		[a-z&&[m-p]]
|		写在方括号的外面表示并集	[a-zA-Z0-9] x|X

.		任意字符(不包括\n)
\d		[0-9]
\D		[^0-9]
\s		[\t\n\x0B\f\r]
\S		[^\s]
\w		[a-zA-Z_0-9]
\W		[^\w]

X?		X,0次或1次
X*		X,0次或多次
X+		X,1次或多次
X{n}	X,正好n次
X{n,}	X,至少n次
X{n,m}	X,至少n次但不超过m次
```

```
[a-d[m-p]]		a到d，或m到p
[a-z&&[def]]	a-z和def的交集,为d,e,f
(?i)		忽略后面字符的大小写,例(?!)abc表示忽略abc的大小写

# 非捕获分组-条件爬取
Java(?=8|11|17)		Java后面跟的数字是8、11、17，获取时只获取前半部分Java
Java(?:8|11|17)		等同于Java(8|11|17),只获取Java8、Java11、Java17
Java(?!8|11|17)		获取内容不包含Java8、Java11、Java17，获取时只获取前半部分Java

# 贪婪爬取(默认)和非贪婪爬取
# 在数量词+ *的后面加上?，那么此时就是非贪婪爬取
abbbbbbbbbb
ab+		abbbbbbbbbb		贪婪爬取
ab+?	ab				非贪婪爬取

分组：()
    捕获分组：后续还要继续使用本组的数据，占用组号
        正则内部：\X
        正则外部: $X
    非捕获分组：分组之后不需要再用本组数据，不占用组号
    	(?:正则)		获取所有
    	(?=正则)		获取前面部分
    	(?!正则)		获取不是指定内容的前面部分
```

